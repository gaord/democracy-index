<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Document</title>
<style>

svg {
	background: #eee;
	font-family: sans-serif;
}

.y.axis, .map {
	text-transform: uppercase;
}

</style>
</head>
<body>
<div class="map"></div>
<div class="plot"></div>
<script src="d3.min.js"></script>  
<script>

/*

appState {
	axisToggle: 1,
	metricToggle: 1,
	religion: "muslim",
	... (index keys)
}

GlobalDispatch
change:religion
	update state
	renderCharts
change:axis
	update state
	renderCharts
change:metric
	update state
	renderCharts
change:indexCategory
	update state
	renderCharts

load dataPromise
- setCategoryKeys

renderUI
- renderCategoryOptions
- renderValueToggle
- renderAxisToggle
- renderReligionMenu

renderCharts

	readState

	dataPromise

	religionYAxis axis === 0
	- getCountryMapData(data)
	- getReligionPlotData(data)
		- renderMap(countryMapData, metric)
		- renderPlot(religionPlotData, metric)

	countryYAxis axis === 1
	- filterByCountry(data)
		- getCountryMapData(filteredData)
		- getCountryPlotData(filteredData)
			- renderMap(countryMapData, metric)
			- renderPlot(countryPlotData, metric)
			
			
----

getCategorySum()
makeKey()
getMax()

*/

const GlobalState = {
	foo:1,
	bar:0
}

const countryDataPromise = d3.json("democracy_religion_long.json");
countryDataPromise.then(data=>{

	const categories = d3.nest()
		.key(d=>d.indexCategory)
		.rollup(values=>d3.mean(values, d=>d.indexScore))
		.entries(data)
		.sort((a,b)=>a.value-b.value)
		.map(d=>{
			d.category = d.key;
			d.key = makeKey(d.key);
			delete d.values;
			return d;
		})

	religionData = d3.nest()
		.key(d=>d.religion)
		.entries(data)
		.map(d=>{
			categories.forEach(j=>{
				d[j.key] = getCategorySum(d.values,j.category)
			})
			const thisReligion = data.filter(j=>j.religion == d.key)
			const thisReligionSum = d3.sum(thisReligion,d=>d.religionPop);
			d.religionSum = thisReligionSum;
			return d;
		})
		.sort((a,b)=>a.religionSum-b.religionSum);
		
	GlobalState.baz = 3;	
		
	console.log(GlobalState);
		
	dataFiltered = data.filter(d=>d.religion==="christian");
		
	countryData = d3.nest()
		.key(d=>d.country)
		.entries(dataFiltered)
		.map(d=>{
			categories.forEach(j=>{
				d[j.key] = getCategorySum(d.values,j.category)
			})
			d.religionSum = d.values[0].allReligions;
			return d;
		})
		.sort((a,b)=>a.religionSum-b.religionSum);
		

	renderChart(religionData, categories);
	renderMap(data)
//	renderChart(countryData, categories);
	
});

function renderMap(data){

	w = 600
	h = 300

	plot = d3.select(".map")
		.append("svg")
		.attr("width",w)
		.attr("height",h);


	countryData = d3.nest()
		.key(d=>d.country)
		.entries(data)
		.map(d=>{
			d.indexScore = d.values[0].indexScore;
			d.indexCategory = d.values[0].indexCategory;
			d.allReligions = d.values[0].allReligions;
			d.lat = d.values[0].lat;
			d.lng = d.values[0].lng;
			return d
		})

  const projection = d3.geoEquirectangular()
    .scale((w/640)*100).translate([w/2, h/2])

  dataXY = countryData.map(d=>{
    d.x = projection([d.lng,d.lat])[0];
    d.y = projection([d.lng,d.lat])[1];
    return d;
  });
	
  var simulation = d3.forceSimulation(dataXY)
    .force('collision', d3.forceCollide().radius(5))
    .on('tick', ticked);
		
		
	lbl = [
		{txt:"North America",lat:32.7865,lng:-97.1148},
		{txt:"South America",lat:-8.7832,lng:-55.4915},
		{txt:"Europe",lat:48.8789,lng:2.32335},
		{txt:"Africa",lat:-8.7832,lng:34.5085},
		{txt:"Asia",lat:34.0479,lng:100.6197}
	]
	
	plot.selectAll("text")
		.data(lbl)
		.enter()
		.append("text")
		.attr("x",d=>projection([d.lng,d.lat])[0])
		.attr("y",d=>projection([d.lng,d.lat])[1])
		.text(d=>d.txt)
		.attr("text-anchor","middle")



  function ticked() {
    var u = plot.selectAll('circle')
      .data(dataXY)

    u.enter()
      .append('circle')
      .attr('r', 5)
      .merge(u)
      .attr('cx', function(d) {
        return d.x
      })
      .attr('cy', function(d) {
        return d.y
      })
      .attr("fill","red")
//      .attr("opacity",0.5)
      .attr("data-country",d=>d.country)

    u.exit().remove()
  }

}

function renderChart(data, categories){

	const indexKeys = categories.map(d=>{
		return d.key;
	})

	maxN = getMax(data, indexKeys);
	

	colors=["red","orange","lime", "green"]

	nRows = data.length
	rowHeight = 15;
	rowMargin = 5;
	
	plotHeight = (nRows * rowHeight) + ((nRows - 1) * rowMargin)

	sy = d3.scaleBand()
		.domain(data.map(d=>d.key))
		.range([plotHeight,0])
		.paddingInner(rowMargin/rowHeight);

	sx = d3.scaleLinear()
		.domain([0,maxN])
		.range([0,500])

	stackGenerator = d3.stack()
		.keys(indexKeys)

	dom = d3.select(".plot")
		.append("svg")
		.attr("width",600)
		.attr("height",plotHeight)
		
	plot = dom.append("g")
		.attr("transform","translate(100,0)")

	g = plot.selectAll(".series")
		.data(stackGenerator(data))
		.enter()
		.append("g")
		.classed("series",true)
		.attr("fill",(d,i)=>colors[i])

	g.selectAll("rect")
		.data(d=>d)
		.enter()
		.append("rect")
		.attr("x",d=>sx(d[0])) // definitely right
		.attr("y",d=>sy(d.data.key))
		.attr("width",d=>sx(d[1])-sx(d[0]))
		.attr("height",sy.bandwidth())	

	 yAxis = d3.axisLeft()
		.scale(sy)
		.tickSize(0)

	dom.append("g")
		.attr("class", "y axis")
		.call(yAxis)
		.attr("transform","translate(100,0)")
		.select(".domain").remove()

}

function getCategorySum(data, category){
	const tmpData = data.filter(d=>d.indexCategory===category);
	const tmpSum = d3.sum(tmpData,d=>d.religionPop)
	return tmpSum;
}

function makeKey(str){
	const newStr = str.replace(/ /g,"").toLowerCase();
	return newStr
}

function getMax(data, keys){
	tmpData = data.map(d=>{
		d.rowNums = d3.sum(keys.map(j=>d[j]))
		return d;
	})
	return d3.max(tmpData,d=>d.rowNums);
}



</script>
</body>
</html>